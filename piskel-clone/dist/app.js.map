{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/components/piskel.js","webpack:///./src/components/tools/SizeTool/sizetools.js","webpack:///./src/components/tools/bucket/bucket.js","webpack:///./src/components/tools/canvas.js","webpack:///./src/components/tools/eraser/eraser.js","webpack:///./src/components/tools/pencil/pencil.js","webpack:///./src/components/tools/stroke/stroke.js","webpack:///./src/components/tools/tools.js","webpack:///./src/index.js","webpack:///./src/scss/main.scss"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8DAA8D;AAC9D,+DAA+D;AAC/D;AACA;AACA;AACA;AACA,+DAA+D;AAC/D,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D,+DAA+D;AAC/D;AACA;;AAEA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACmB;;;AAGnB;AACA;AACA,uB;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2C;AACT;AACY;AAC9C;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,mBAAmB,IAAI,2DAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB,IAAI,2DAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8CAAG;AACZ,QAAQ,8CAAG,gCAAgC,2DAAI,WAAW,2DAAI,Y;AAC9D;AACA;AACA,YAAY,+CAAK,iB;AACjB,qCAAqC,iDAAM;AAC3C,qCAAqC,iDAAM;AAC3C,+BAA+B;AAC/B;;AAEA,0BAA0B,8CAAG;AAC7B;AACA;AACA;AACA;AACwB;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,wBAAwB;;AAEhD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iCAAiC;AACrE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iCAAiC;AACzE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iCAAiC;AACrE;;AAEA;AACA;AACA;AACA;AACA;A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","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","const canvas = document.querySelector('.mainbox');\r\nconst firstpage = document.querySelector('.start-page');\r\nconst startbtn = document.querySelector('.start-btn');\r\nconst gobackbtn = document.querySelector('.TODO')//TO DO\r\nconst canvas_item = document.querySelector('.canvas');\r\nconst grid = document.createElement('div');\r\ngrid.classList.add('canvas_grid');\r\nconst CANVAS_SIZE = 768;\r\nclass MyPiskelClone{\r\n    constructor(firstpage,canvas,startbtn,gobackbtn){\r\n        this.firstpage = firstpage;\r\n        this.canvas = canvas;\r\n        this.startbtn = startbtn;\r\n        this.gobackbtn = gobackbtn;\r\n        this.startbtn.addEventListener('click',()=>{\r\n            this.StartPiskel();\r\n        })\r\n        /* this.gobackbtn.addEventListener('click',()=>{\r\n            this.GoLending();\r\n        }) */\r\n    \r\n    }\r\n    \r\n    StartPiskel(){\r\n        this.firstpage.style = \"display:none\";\r\n        this.canvas.style = \"display:block\";\r\n        \r\n        canvas_item.appendChild(grid);\r\n        for(let i = 0 ; i < CANVAS_SIZE; i+=32){\r\n            console.log('work');\r\n            let canvas_line = document.createElement('div');\r\n            for(let j = 0 ; j < CANVAS_SIZE ; j+=32){\r\n            let node = document.createElement('div');\r\n            node.classList.add('canvas_squade');\r\n            canvas_line.appendChild(node);\r\n            canvas_line.classList.add('canvas_line');\r\n        }\r\n        grid.appendChild(canvas_line);\r\n        }\r\n    }\r\n    GoLending(){\r\n        this.firstpage.style = \"display:block\";\r\n        this.canvas.srtle = \"display:none\";\r\n    }\r\n\r\n}\r\nconst mypiskel = new MyPiskelClone(firstpage,canvas,startbtn,gobackbtn);\r\nexport {mypiskel,MyPiskelClone,grid};","import {pencil} from '../pencil/pencil.js';\r\nconst DEFAULT_SIZE_DRAW = 32;\r\nconst active_small = document.querySelector('.size_active--small');\r\nconst active_medium = document.querySelector('.size_active--medium');\r\nconst active_large = document.querySelector('.size_active--large');\r\nclass Size{\r\n    constructor(_default_size){\r\n        this.item_size = _default_size;\r\n        this.item_prev = active_small;\r\n        this.items = document.querySelectorAll('.size_info');\r\n        this.items.forEach((elem)=>{\r\n            \r\n            elem.addEventListener('click',(event)=>{\r\n                if(event.currentTarget.id == 'small')  {\r\n                    this.item_size = SMALL_SIZE;\r\n                    active_small.style = \"visibility: visible;\";\r\n                    this.item_prev.style = \"visibility: hidden;\";\r\n                    this.item_prev = active_small;\r\n                }\r\n                if(event.currentTarget.id == 'medium') {\r\n                    this.item_size = MEDUIM_SIZE;\r\n                    active_medium.style = \"visibility: visible;\";\r\n                    this.item_prev.style = \"visibility: hidden;\";\r\n                    this.item_prev = active_medium;\r\n                }\r\n                if(event.currentTarget.id == 'large')  \r\n                {\r\n                    this.item_size = LARGE_SIZE;\r\n                    active_large.style = \"visibility: visible;\";\r\n                    this.item_prev.style = \"visibility: hidden;\";\r\n                    this.item_prev = active_large;\r\n                }\r\n                \r\n            })\r\n        })\r\n    }\r\n    toSmall(){\r\n        tools.size = SMALL_SIZE;\r\n    }\r\n    toMedium(){\r\n        tools.size = MEDUIM_SIZE;\r\n    }\r\n    toLarge(){\r\n        tools.size = LARGE_SIZE;\r\n    }\r\n\r\n}\r\n\r\nconst size = new Size(DEFAULT_SIZE_DRAW);\r\nexport {size,Size};\r\n\r\n\r\nconst SMALL_SIZE = 32;\r\nconst MEDUIM_SIZE = 64;\r\nconst LARGE_SIZE = 128;","import { canvas, ctx } from \"../canvas.js\";\r\nimport {tools} from '../tools.js';\r\nimport {size} from '../SizeTool/sizetools.js';\r\nconst CANVAS_SIZE = 768;\r\nclass Bucket{\r\n    constructor(_color){\r\n        this.color  = _color;\r\n        this.mouse = {x:0, y:0};\r\n    }\r\n    AllBucket(){\r\n\r\n    }\r\n    HalfBucket(){\r\n\r\n    }\r\n    setPixel(x0,y0){\r\n        var resultXmax,resultXmin,resultYmax,resultYmin;\r\n        for(let i = 0 ; i <= CANVAS_SIZE ; i+=size.item_size){\r\n            if( i > x0){\r\n                resultXmax = i;\r\n                break;\r\n            }\r\n            if(i < x0){\r\n                resultXmin = i;\r\n            }\r\n        }\r\n        for(let i = 0 ; i <= CANVAS_SIZE ; i+=size.item_size){\r\n            if(i > y0){\r\n              resultYmax = i;\r\n                break;\r\n            }\r\n            if(i < y0){\r\n                resultYmin = i;\r\n            }\r\n        }\r\n         ctx.fillStyle= this.color;\r\n        ctx.fillRect(resultXmin,resultYmin,size.item_size,size.item_size);     \r\n    }\r\n    MouseDown(e){\r\n        if (tools.id == 'bucket'){   \r\n            this.mouse.x = e.pageX - canvas.offsetLeft;\r\n            this.mouse.y = e.pageY - canvas.offsetTop;\r\n            var _background = {r: 240, g: 52, b: 52, a: 0};\r\n            var cff = new CanvasFloodFiller();\r\n\r\n            cff.floodFill(ctx, this.mouse.x,this.mouse.y, _background);\r\n        }\r\n    }\r\n}\r\nconst bucket = new Bucket(\"#008\")\r\nexport {bucket, Bucket};\r\nfunction CanvasFloodFiller()\r\n{\r\n    // Ширина и высота канвы\r\n    var _cWidth = 768;\r\n    var _cHeight = 768;\r\n \r\n    // Заменяемый цвет\r\n    var _rR = 0;\r\n    var _rG = 0;\r\n    var _rB = 0;\r\n    var _rA = 0;\r\n \r\n    // Цвет закраски\r\n    var _nR = 0;\r\n    var _nG = 0;\r\n    var _nB = 0;\r\n    var _nA = 0;\r\n \r\n    var _data = null;\r\n \r\n    /*\r\n     * Получить точку из данных\r\n     **/\r\n    var getDot = function(x, y)\r\n    {\r\n        // Точка: y * ширину_канвы * 4 + (x * 4)\r\n        var dstart = (y * _cWidth * 4) + (x * 4);\r\n        var dr = _data[dstart];\r\n        var dg = _data[dstart + 1];\r\n        var db = _data[dstart + 2];\r\n        var da = _data[dstart + 3];\r\n \r\n        return {r: dr, g: dg, b: db, a: da};\r\n    }\r\n \r\n    /*\r\n     * Пиксель по координатам x,y - готовый к заливке?\r\n     **/\r\n    var isNeededPixel = function(x, y)\r\n    {\r\n        var dstart = (y * _cWidth * 4) + (x * 4);\r\n        var dr = _data[dstart];\r\n        var dg = _data[dstart + 1];\r\n        var db = _data[dstart + 2];\r\n        var da = _data[dstart + 3];\r\n \r\n        return (dr == _rR && dg == _rG && db == _rB && da == _rA);\r\n    }\r\n \r\n    /*\r\n     * Найти левый пиксель, по пути закрашивая все попавшиеся\r\n     **/\r\n    var findLeftPixel = function(x, y)\r\n    {\r\n        // Крутим пикселы влево, заодно красим. Возвращаем левую границу.\r\n        // Во избежание дубляжа и ошибок, findLeftPixel НЕ красит текущий\r\n        // пиксел! Это сделает обязательный поиск вправо.\r\n        var lx = x - 1;\r\n        var dCoord = (y * _cWidth * 4) + (lx * 4);\r\n \r\n        while (lx >= 0 && _data[dCoord] == _rR && _data[dCoord + 1] == _rG &&\r\n            _data[dCoord + 2] == _rB && _data[dCoord + 3] == _rA)\r\n        {\r\n            _data[dCoord] = _nR;\r\n            _data[dCoord + 1] = _nG;\r\n            _data[dCoord + 2] = _nB;\r\n            _data[dCoord + 3] = _nA;\r\n \r\n            lx--;\r\n            dCoord -= 4;\r\n        }\r\n \r\n        return lx + 1;\r\n    }\r\n \r\n    /*\r\n     * Найти правый пиксель, по пути закрашивая все попавшиеся\r\n     **/\r\n    var findRightPixel = function(x, y)\r\n    {\r\n        var rx = x;\r\n        var dCoord = (y * _cWidth * 4) + (x * 4);\r\n \r\n        while (rx < _cWidth && _data[dCoord] == _rR && _data[dCoord + 1] == _rG &&\r\n            _data[dCoord + 2] == _rB && _data[dCoord + 3] == _rA)\r\n        {\r\n            _data[dCoord] = _nR;\r\n            _data[dCoord + 1] = _nG;\r\n            _data[dCoord + 2] = _nB;\r\n            _data[dCoord + 3] = _nA;\r\n \r\n            rx++;\r\n            dCoord += 4;\r\n        }\r\n \r\n        return rx - 1;\r\n    }\r\n \r\n    /*\r\n     * Эффективная (строчная) заливка\r\n     **/\r\n    var effectiveFill = function(cx, cy)\r\n    {\r\n        var lineQueue = new Array();\r\n \r\n        var fx1 = findLeftPixel(cx, cy);\r\n        var fx2 = findRightPixel(cx, cy);\r\n \r\n        lineQueue.push({x1: fx1, x2: fx2, y: cy});\r\n \r\n        while (lineQueue.length > 0)\r\n        {\r\n            var cLine = lineQueue.shift();\r\n            var nx1 = cLine.x1;\r\n            var nx2 = cLine.x1;\r\n            var currx = nx2;\r\n \r\n            // Сперва для первого пиксела, если верхний над ним цвет подходит,\r\n            // пускаем поиск левой границы.\r\n            // Можно искать вверх?\r\n            if (cLine.y > 0)\r\n            {\r\n                // Сверху строка может идти левее текущей?\r\n                if (isNeededPixel(cLine.x1, cLine.y - 1))\r\n                {\r\n                    // Ищем в том числе влево\r\n                    nx1 = findLeftPixel(cLine.x1, cLine.y - 1);\r\n                    nx2 = findRightPixel(cLine.x1, cLine.y - 1);\r\n                    lineQueue.push({x1: nx1, x2: nx2, y: cLine.y - 1});\r\n                }\r\n \r\n                currx = nx2;\r\n                // Добираем недостающее, ищем только вправо, но пока не\r\n                // доползли так или иначе далее края текущей строки\r\n                while (cLine.x2 >= nx2 && currx <= cLine.x2 && currx < (_cWidth - 1))\r\n                {\r\n                    currx++;\r\n \r\n                    if (isNeededPixel(currx, cLine.y - 1))\r\n                    {\r\n                        // Сохраняем найденный отрезок\r\n                        nx1 = currx;\r\n                        nx2 = findRightPixel(currx, cLine.y - 1);\r\n                        lineQueue.push({x1: nx1, x2: nx2, y: cLine.y - 1});\r\n                        // Прыгаем далее найденного\r\n                        currx = nx2;\r\n                    }\r\n                }\r\n            }\r\n \r\n            nx1 = cLine.x1;\r\n            nx2 = cLine.x1;\r\n            // Те же яйца, но можно ли искать вниз?\r\n            if (cLine.y < (_cHeight - 1))\r\n            {\r\n                // Снизу строка может идти левее текущей?\r\n                if (isNeededPixel(cLine.x1, cLine.y + 1))\r\n                {\r\n                    // Ищем в том числе влево\r\n                    nx1 = findLeftPixel(cLine.x1, cLine.y + 1);\r\n                    nx2 = findRightPixel(cLine.x1, cLine.y + 1);\r\n                    lineQueue.push({x1: nx1, x2: nx2, y: cLine.y + 1});\r\n                }\r\n \r\n                currx = nx2;\r\n                // Добираем недостающее, ищем только вправо, но пока не\r\n                // доползли так или иначе далее края текущей строки\r\n                while (cLine.x2 >= nx2 && currx <= cLine.x2 && currx < (_cWidth - 1))\r\n                {\r\n                    currx++;\r\n \r\n                    if (isNeededPixel(currx, cLine.y + 1))\r\n                    {\r\n                        // Сохраняем найденный отрезок\r\n                        nx1 = currx;\r\n                        nx2 = findRightPixel(currx, cLine.y + 1);\r\n                        lineQueue.push({x1: nx1, x2: nx2, y: cLine.y + 1});\r\n                        // Прыгаем далее найденного\r\n                        currx = nx2;\r\n                    }\r\n                }\r\n            }\r\n \r\n        }   // while (main loop)\r\n    }\r\n \r\n    /*\r\n     * void floodFill(CanvasContext2D canvasContext, int x, int y)\r\n     * Выполняет заливку на канве\r\n     * canvasContext - контекст\r\n     * int x, y - координаты точки заливки\r\n     * color - цвет заливки\r\n     */\r\n    this.floodFill = function(canvasContext, x, y, color)\r\n    {\r\n        \r\n               _cWidth = canvasContext.canvas.width;\r\n        _cHeight = canvasContext.canvas.height;\r\n        \r\n        _nR = color.r;\r\n        _nG = color.g;\r\n        _nB = color.b;\r\n        _nA = color.a;\r\n        var idata = canvasContext.getImageData(0, 0, _cWidth, _cHeight);\r\n        var pixels = idata.data;\r\n        _data = pixels;\r\n \r\n        var toReplace = getDot(x, y);\r\n        _rR = toReplace.r;\r\n        _rG = toReplace.g;\r\n        _rB = toReplace.b;\r\n        _rA = toReplace.a;\r\n \r\n        // Всё зависнет к известной матери если цвета совпадают\r\n        if (_rR == _nR && _rG == _nG && _rB == _nB && _rA == _nA)\r\n            return;\r\n \r\n        effectiveFill(x, y);\r\n        console.log(idata);\r\n        console.log(canvasContext.putImageData(idata, 0, 0));\r\n    }\r\n}","\r\nconst canvas = document.querySelector('canvas');\r\nconst ctx = canvas.getContext('2d');\r\n \r\nfunction saveImage() {\r\n    var image = canvas.toDataURL(\"image/png\").replace(\"image/png\", \"image/octet-stream\"); \r\n    window.location.href=image; // it will save locally\r\n}\r\nexport {canvas, ctx, saveImage};","import {pencil,Pencil} from '../pencil/pencil.js';\r\nconst ERASER_COLOR = \"#fff\";\r\nclass Eraser extends Pencil{\r\n    constructor(){\r\n        super();\r\n        this.color = ERASER_COLOR;\r\n    }\r\n\r\n}\r\nconst eraser = new Eraser();\r\nexport {eraser, Eraser};\r\n","import { canvas,ctx } from \"../canvas\";\r\nimport {tools} from '../tools.js';\r\nimport {size} from '../SizeTool/sizetools.js';\r\nconst CANVAS_SIZE = 768;\r\nclass Pencil{\r\n    constructor(color){\r\n        this.color = color;\r\n        this.mouse = {x:0, y:0};\r\n        this.prevdot = {x:0 , y:0};\r\n        this.draw = false;\r\n    }\r\n     MouseDown(e){\r\n         console.log('work');\r\n        if (tools.id == 'pencil' || tools.id == 'eraser'){   \r\n        this.mouse.x = e.pageX - canvas.offsetLeft;\r\n        this.mouse.y = e.pageY - canvas.offsetTop;\r\n        this.setPixel(this.mouse.x,this.mouse.y);\r\n        console.log(this.mouse.x,this.mouse.y);\r\n        this.draw = true;\r\n        }\r\n    }\r\n     Mousemove(e){\r\n        if(tools.id == 'pencil' || tools.id == 'eraser'|| tools.id == 'stroke'){\r\n            if(this.draw == true){\r\n                this.prevdot.x = this.mouse.x;\r\n                this.prevdot.y = this.mouse.y;\r\n                this.mouse.x = e.pageX - canvas.offsetLeft;\r\n                this.mouse.y = e.pageY - canvas.offsetTop;\r\n                this.Line(this.prevdot.x,this.prevdot.y,this.mouse.x,this.mouse.y);               \r\n            }\r\n        }\r\n               \r\n        }\r\n     Mouseup(e){\r\n        if(tools.id == 'pencil' || tools.id == 'eraser'|| tools.id == 'stroke'){\r\n            this.mouse.x = e.pageX - canvas.offsetLeft;\r\n            this.mouse.y = e.pageY - canvas.offsetTop;\r\n            this.draw = false;\r\n        }\r\n    }\r\n     setPixel(x0,y0){\r\n        var resultXmax,resultXmin,resultYmax,resultYmin;\r\n        for(let i = 0 ; i <= CANVAS_SIZE ; i+=size.item_size){\r\n            if( i > x0){\r\n                resultXmax = i;\r\n                break;\r\n            }\r\n            if(i < x0){\r\n                resultXmin = i;\r\n            }\r\n        }\r\n        for(let i = 0 ; i <= CANVAS_SIZE ; i+=size.item_size){\r\n            if(i > y0){\r\n              resultYmax = i;\r\n                break;\r\n            }\r\n            if(i < y0){\r\n                resultYmin = i;\r\n            }\r\n        }\r\n         ctx.fillStyle= this.color;\r\n        ctx.fillRect(resultXmin,resultYmin,size.item_size,size.item_size);     \r\n    }\r\n     Line(x0, y0, x1, y1){\r\n        var dx = Math.abs(x1-x0);\r\n        var dy = Math.abs(y1-y0);\r\n        var sx = (x0 < x1) ? 1 : -1;\r\n        var sy = (y0 < y1) ? 1 : -1;\r\n        var err = dx-dy;\r\n     \r\n        while(true){\r\n          this.setPixel(x0,y0);\r\n          if ((x0==x1) && (y0==y1)) break;\r\n          var e2 = 2*err;\r\n          if (e2 >-dy){ err -= dy; x0  += sx; }\r\n          if (e2 < dx){ err += dx; y0  += sy; }\r\n        }\r\n     }\r\n}\r\nconst pencilbtn = document.querySelector('.pencil');\r\nconst pencil = new Pencil(\"#000\",pencilbtn);\r\n \r\nexport {pencil,Pencil};","import {pencil,Pencil} from '../pencil/pencil.js';\r\nimport {tools} from '../tools.js';\r\nimport {canvas} from \"../canvas.js\";\r\nimport {size} from '../SizeTool/sizetools.js';\r\nvar flag = false;\r\nclass Stroke extends Pencil{\r\n    constructor(color){\r\n        super(color);\r\n        this.startPixel = {x:0, y:0};\r\n        this.nextPixel = {x:0, y:0,};\r\n        this.state = false;\r\n    }\r\n    Stroke(x,y){\r\n    \r\n    }\r\n    MouseDown(e){\r\n        console.log('stroke work');\r\n        if(tools.id == 'stroke'){\r\n            if(flag){\r\n                this.startPixel = {x:0, y:0};\r\n                this.nextPixel = {x:0, y:0,};\r\n                flag = !flag;\r\n            }\r\n            if(!this.state){\r\n                this.startPixel.x =  e.pageX - canvas.offsetLeft;\r\n                this.startPixel.y = e.pageY - canvas.offsetTop;\r\n                this.state = !this.state;\r\n                }\r\n            else{\r\n                this.nextPixel.x = e.pageX - canvas.offsetLeft;\r\n                this.nextPixel.y = e.pageY - canvas.offsetTop;\r\n                this.state = !this.state;\r\n                flag = !flag;\r\n\r\n            }\r\n            if(this.startPixel.x != 0 && this.nextPixel.x != 0){\r\n                if(Math.abs(this.nextPixel.y - this.startPixel.y) <= size.item_size){\r\n                    let width = this.nextPixel.x - this.startPixel.x;\r\n                    if(width <= size.item_size * 2){\r\n                        this.setPixel(this.startPixel.x,this.startPixel.y);\r\n                        this.setPixel(this.nextPixel.x,this.nextPixel.y);\r\n                    }\r\n                    if(width <= 0){\r\n                        for(let i = this.nextPixel.x; i <= this.startPixel.x; i++){\r\n                            this.setPixel(i,this.nextPixel.y);\r\n                        }\r\n                    }\r\n                    else{\r\n                        for(let i = this.startPixel.x; i <= this.nextPixel.x; i++){\r\n                            this.setPixel(i,this.startPixel.y);\r\n                        }    \r\n                    }\r\n                }\r\n                else{\r\n                    if(Math.abs(this.nextPixel.x - this.startPixel.x) <= size.item_size){\r\n                        let heigth = this.nextPixel.y - this.startPixel.y;\r\n                        if(heigth <= 0){\r\n                            for(let i = this.nextPixel.y; i <= this.startPixel.y; i++){\r\n                                this.setPixel(this.nextPixel.x, i);\r\n                            }\r\n                        }\r\n                        else{\r\n                            for(let i = this.startPixel.y; i <= this.nextPixel.y; i++){\r\n                                this.setPixel(this.startPixel.x, i);\r\n                            }    \r\n                        }\r\n                        \r\n                    }\r\n                    this.startPixel = {x:0, y:0};\r\n                    this.nextPixel = {x:0, y:0,};\r\n                }\r\n                \r\n            }    \r\n        }\r\n               \r\n        }\r\n    \r\n}\r\nconst stroke = new Stroke(\"#000\");\r\nexport {stroke, Stroke};","class Tools{\r\n    constructor(_tools,size){\r\n        this.prev_tool = null;\r\n        this.tool = null;\r\n        this.id = null;\r\n        this.tools = _tools;\r\n        this.tools.forEach((item)=>{\r\n            item.addEventListener('click',(event)=>{\r\n                if(this.tool === null) this.prev_tool = event.currentTarget;\r\n                this.tool = event.currentTarget;\r\n                this.id = this.tool.id;\r\n                Tools.ChangeTool(this.tool,this.prev_tool,this.tool.id);//checked\r\n                this.prev_tool = event.currentTarget;\r\n            })\r\n        })\r\n    }\r\n    static ChangeTool(tool,prev_tool,id){\r\n        if(prev_tool !== null) prev_tool.classList.toggle('tools_icon--active',false);\r\n        tool.classList.add('tools_icon--active');\r\n    }\r\n    \r\n}\r\nconst tools = new Tools(document.querySelectorAll('.tools__item--element'));\r\nexport {tools,Tools};","import './scss/main.scss';\r\nimport {tools} from './components/tools/tools.js';\r\nimport {canvas,saveImage} from './components/tools/canvas.js';\r\nimport {pencil} from './components/tools/pencil/pencil';\r\nimport {bucket} from './components/tools/bucket/bucket.js';\r\nimport {eraser} from './components/tools/eraser/eraser.js';\r\nimport {grid} from './components/piskel.js';\r\nimport {stroke} from './components/tools/stroke/stroke.js';\r\n\r\ngrid.addEventListener('mousedown', (event)=>{\r\n    console.log(event);\r\n    switch (tools.id) {\r\n        case \"pencil\":pencil.MouseDown(event);break;\r\n        case \"allbucket\":break;\r\n        case \"eraser\":eraser.MouseDown(event);break;\r\n        case \"stroke\":console.log(stroke);stroke.MouseDown(event);break;\r\n        default:\r\n            break;\r\n    }\r\n});\r\ngrid.addEventListener('mousemove',(event)=>{\r\n  \r\n   switch (tools.id) {\r\n       case \"pencil\":pencil.Mousemove(event);break;\r\n       case \"eraser\":eraser.Mousemove(event);break;\r\n       default:\r\n           break;\r\n   }\r\n    \r\n});\r\ngrid.addEventListener('mouseup', (event)=>{\r\n    switch (tools.id) {\r\n        case \"pencil\": pencil.Mouseup(event);saveImage();break;\r\n        case \"eraser\":eraser.Mouseup(event);break;\r\n        default:\r\n            break;\r\n    }\r\n});","// removed by extract-text-webpack-plugin"],"sourceRoot":""}